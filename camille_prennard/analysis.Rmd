---
# General Information --------------------------------------------------------
title:    "Camille Prennard - thèse"
subtitle: ""
author:   "Francesco MONTI"
date:     "`r Sys.time()`" # Automatic date# Document Format and Appearance ---------------------------------------------
# type ?html_document for more details
output:
    bookdown::html_document2: 
        toc:         yes        # Table of contents (toc): yes no
        toc_float:   yes        # yes no
        toc_depth:   3              # 1 2 3 4 5
        highlight : pygments      # default tango kate monochrome espresso pygments...
        highlight_downlit : FALSE      # TRUE to use the downlit package as syntax highlight engine to highlight inline code and R code chunks (including providing hyperlinks to function documentation). The package needs to be installed to use this feature.
        code_folding:    "hide"     # none show hide
        code_download:   yes        # yes no
        fig_caption: yes        # yes no
        fig_width : 7
        fig_height : 5
        fig_retina : 2
        theme:       default        # cerulean journal flatly readable paper sandstone ...
        df_print:    default        # paged kable tibble default
        number_sections: yes        # Automatic numbering of sections: yes no
        anchor_sections : FALSE
        section_divs : TRUE     # Wrap sections in <div> tags, and attach identifiers to the enclosing <div> rather than the header itself.
        dev : "svg"                # Graphics device to use for figure output (defaults to png)
        self_contained : TRUE
        extra_dependencies : NULL    # Extra dependencies as a list of the html_dependency class objects typically generated by htmltools:htmlDependency().
        css : NULL     # CSS and/or Sass files to include. Files with an extension of .sass or .scss are compiled to CSS via sass::sass(). Also, if theme is a bslib::bs_theme() object, Sass code may reference the relevant Bootstrap Sass variables, functions, mixins, etc.
        includes : NULL        # Named list of additional content to include within the document (typically created using the includes function)
        keep_md : FALSE        # Keep the markdown file generated by knitting.
        lib_dir : NULL             #    Directory to copy dependent HTML libraries (e.g. jquery, bootstrap, etc.) into. By default this will be the name of the document with _files appended to it.
        md_extensions : NULL       # Markdown extensions to be added or removed from the default definition of R Markdown. See the rmarkdown_format for additional details.
        pandoc_args : NULL      # Additional command line options to pass to pandoc
        template : "default"       # Pandoc template to use for rendering. Pass "default" to use the rmarkdown package default template; pass NULL to use pandoc's built-in template; pass a path to use a custom template that you've created. Note that if you don't use the "default" template then some features of html_document won't be available (see the Templates section below for more details).
        math_method : "default"        # Math rendering engine to use. This will define the math method to use with Pandoc. It can be a string for the engine, one of "mathjax", "mathml", "webtex", "katex", "gladtex", or "r-katex" or "default" for mathjax.
                                # It can be a list of
                                # - engine: one of "mathjax", "mathml", "webtex", "katex", or "gladtex". 
                                # - url: A specific url to use with mathjax, katex or webtex. 
                            # Note that for engine = "mathjax", url = "local" will use a local version of 
                            # MathJax (which is copied into the output directory).
                            # For example,
                            # output:
                            #    html_document:
                            #        math_method:
                            #        engine: katex
                            #        url: https://cdn.jsdelivr.net/npm/katex@0.11.1/dist
                            #        See Pandoc's Manual about Math in HTML for the details about Pandoc 
                            #        supported methods.

                        # Using math_method = "r-katex" will opt-in server side rendering using KaTeX thanks to katex R package. 
                        # This is useful compared to math_method = "katex" to have no JS dependency, only a CSS dependency for styling equation.
        mathjax : "default"        # Include mathjax. The "default" option uses an https URL from a MathJax CDN. The "local" option uses a local version of MathJax (which is copied into the output directory). You can pass an alternate URL or pass NULL to exclude MathJax entirely.
---


```{r setup, include=FALSE}
# Packages ------------------------------------------------------------------

library(tidyverse)     # The main "tidyverse" packages.
library(magrittr)
library(openxlsx)
library(ggplot2)
library(pander)        # Function `pander()` to report results of statistical analysis.
library(knitr)         # Function `kable()` to convert data frames into tables for reports.
library(DT)            # Interactive tables for HTML documents (DataTables).
library(gt)            # Easily Create Presentation-Ready Display Tables.
library(flextable)     # Functions for Tabular Reporting.
library(stringr)
library(DT)
library(fmckage)

# Settings ------------------------------------------------------------------

Sys.getlocale()

# Chunk options
knitr::opts_chunk$set(
  echo       = TRUE,    # Should blocks with program code be shown in knitted documents?
  eval       = TRUE,    # Should program code be evaluated?
  fig.height = 3,       # Default height for plots.
  fig.width  = 5,       # Default width for plots.
  fig.align  = "center" # Default alignment for plots in knitted documents.
)

# Options to format numbers
options(        # For more detais see ?options
  scipen = 8,   # Show at least 8 digits in numbers before converting to exponential notation.
    digits = 3,   # Number of significant digits to print numbers.
    OutDec = ".", # Default decimal separator to print numbers.
    knitr.kable.NA = NA # Replacement for NA values in knitr::kable()
)

# Options for package "pander"
options(
  pander = modifyList(
    pander::panderOptions(),
    list(
      digits = getOption("digits", default = 3),
      round  = Inf,
      decimal.mark = getOption("OutDec", default = "."),
      big.mark = "",
      keep.trailing.zeros = TRUE,
      missing = getOption("knitr.kable.NA", default = NA),
      table.style = "multiline", # "multiline", "grid", "simple", "rmarkdown"
      table.split.table = 80,
      table.split.cells = 30,
      table.continues   = "Table continues below",
      table.continues.affix = "(continued below)",
      p.wrap   = "_",
      p.sep    = ", ",
      p.copula = " and ",
      knitr.auto.asis = TRUE
    ))
)


ggplot2::theme_set(ggplot2::theme_bw()) # Default ggplot2 theme

conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("lag",    "dplyr")

set.seed(20230604) # Initial condition for random processes.
```

```{r load, echo = F}
pre = read.xlsx("Résultats pré test.xlsx")
post = read.xlsx("Résultats post test.xlsx")
good_answers = read.xlsx("good_answers.xlsx")

# Fixing 1 missing value
pre = pre %>% 
    rename_all(~ str_replace_all(., "\\.", "_")) %>% 
    tibble() %>% 
    mutate(`Quel_est_votre_formation_?` = replace_na(`Quel_est_votre_formation_?`,"Soins infirmiers")) %>% mutate(test = "pre") 

post = post %>% 
    rename_all(~ str_replace_all(., "\\.", "_")) %>% 
    tibble %>% mutate(test = "post")

# Merging pre and post results
data = rbind(pre,post) %>%
    rename("filiere" = `Quel_est_votre_formation_?`)


```

```{r include = F}
good_answers = good_answers %>% pivot_wider(names_from = "question", values_from = "answer")
good_answers[2:nrow(data),] = good_answers[1,]

# renaming  every column in "pre" and "post" to make it more readable and concise
names(data)[9:63] = names(good_answers)[1:55]

data %>% mutate(across(9:63, function(x) ifelse(x == good_answers,1,0)))

result=data
for(i in 9:63) {
   
        result[,i] = ifelse(data[,i] == good_answers[,i-8],1,0)
        
    }

```


# Tableau de control

Ce tableau te permettra de faire un control sur le tien. 

```{r}
# quality check good answers
    # overall
overall = result %>%
    relocate(test, .before = Date_de_soumission) %>%
    pivot_longer(cols = fin_de_vie:last_col(), names_to = "question", values_to = "answer") %>%
    count(test, question, answer) %>%
    group_by(test, question) %>%
    mutate("%" = round(n * 100 / sum(n, na.rm = T), 2)) %>%
    filter(answer == 1) %>%
    select(-answer, -n) %>% 
    pivot_wider(names_from = test, values_from = "%") %>% 
    relocate(pre, .before = "post")


    # by filiere
byfiliere = result %>%
  relocate(test, .before = Date_de_soumission) %>%
  pivot_longer(cols = fin_de_vie:last_col(), names_to = "question", values_to = "answer") %>%
  count(test, question, filiere, answer) %>%
  group_by(test, question, filiere) %>%
  mutate("%" = round(n * 100 / sum(n, na.rm = T), 2)) %>%
  filter(answer == 1) %>%
  select(-answer, -n) %>%
  pivot_wider(names_from = c(filiere), values_from = "%") %>%
  relocate("Soins infirmiers", .after = "question") %>%
  relocate("Maieutique", .after = last_col()) %>%
  pivot_wider(names_from = test, values_from = "Soins infirmiers":"Maieutique") %>%
  relocate("Soins infirmiers_pre", .before = "Soins infirmiers_post") %>%
  relocate("médecine générale_pre", .before = "médecine générale_post") %>%
  relocate("orthophonie_pre", .before = "orthophonie_post") %>%
  relocate("Pharmacie_pre", .before = "Pharmacie_post") %>%
  relocate("Maieutique_pre", .before = "Maieutique_post") %>%
  replace_na(list("Maieutique_pre" = 0, "Maieutique_post" = 0)) 


# printing datatable
cbind(overall,byfiliere[-1]) %>% 
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))

```


# "Score" par sujet
Dans ce tableau tu as le % de bonnes (1) et mauvaise (0) réponses pour chaque sujet. Tu as 51 sujet ce qui nous donne 51*2=102 lignes. Parfait.
```{r}
# reponses pour chaque sujet
result %>%
  relocate(test, .before = Date_de_soumission) %>%
  pivot_longer(cols = fin_de_vie:last_col(), names_to = "question", values_to = "answer") %>%
  group_by(code, filiere, test) %>%
  count(answer) %>%
  arrange(code, filiere, desc(test)) %>%
  group_by(code, filiere, test) %>%
  mutate("%" = round(n * 100 / sum(n, na.rm = t), 2)) %>% 
    pivot_wider(names_from = "answer", values_from = c("n","%")) %>% 
  datatable(options = list(
    pageLength = 10,
    # dom = 't',
    scrollX = TRUE,
    width = "auto",
    scrollX = T
  ))
```


# McNemar Test (avec correction de continuité)
Le test de McNemar est utilisé pour analyser des données catégorielles appariées lorsque l'on souhaite évaluer la différence de proportions ou de fréquences entre deux groupes ou conditions apparentés. Il est couramment appliqué lorsque **les mêmes sujets** sont mesurés ou évalués à **deux moments différents** ou dans deux conditions différentes.

Le test est approprié lorsque les données suivent une structure spécifique : un tableau de contingence 2x2 où les deux groupes sont comparés sur un résultat binaire (par exemple, succès/échec, oui/non). Dans notre cas "avant"/"après" **vs** "bonne"/"mauvaise reponse".

L'interprétation des résultats d'un test de McNemar implique l'examen de la valeur p obtenue. La valeur p indique la probabilité d'observer un résultat aussi extrême que celui obtenu purement par hasard, comme s'il n'y avait pas de différence entre les deux groupes apparentés. Si la valeur p est inférieure à un seuil de signification préétabli (par exemple, 0,05), cela signifie qu'il existe des preuves d'une différence significative entre les deux groupes.

Voici une ligne directrice générale pour l'interprétation des résultats d'un test de McNemar :

- Si la valeur p est inférieure au seuil de signification (par exemple, p < 0,05), cela signifie qu'il existe une différence significative entre les groupes appariés.
- Si la valeur p est supérieure au seuil de signification (p > 0,05, par exemple), cela signifie qu'il n'y a pas suffisamment de preuves pour conclure à une différence significative entre les groupes appariés. En d'autres termes, les données ne permettent pas de rejeter l'hypothèse nulle d'absence de différence.

Vu que les effectifs pour l'analyse en sous-groupes sont **très** faibles on va appliquer une correction de continuité. La correction de continuité est une technique utilisée dans certains tests statistiques, notamment le test du chi carré et le test de McNemar, pour améliorer l'approximation des valeurs p dans les situations où le nombre de cellules attendues est faible. Généralement si le contenu des cellules de la matrice de contingence 2x2 est n<5. Et on a seulement les IDE qui sont >20 donc les autre filières ont forcement au moins une cellule avec n<5.

D'abord on fait le test sur l'ensemble de ta population puis en sous-groupes. Je te conseille d'ignorer le test sur les sages-femme parce qu'elles ne sont que 2, ça serait un peu ridicule à presenter à la thèse comme un résultat significatif...
Les autres groupes sont très faibles aussi, c'est un peu abusé l'analyse en sous-groupes. Je comprends que ta/ton chef te mets surement la pression mais je prefère te le dire honettement.
Voici donc les calcules:


```{r }
x = result %>% 
    relocate(test, .before = Date_de_soumission) %>%
    pivot_longer(cols = fin_de_vie:last_col(), 
                 names_to = "question", values_to = "answer") %>%
    select(code,test,filiere,question,answer)

overall_p = table(x$test,x$answer) %>% mcnemar.test()

x_split <- split(x, x$filiere)
x_p_values <- sapply(x_split, function(df) {
    tbl <- table(df$test, df$answer)
    test_result <- mcnemar.test(tbl, correct = T)
    test_result$p.value
})

paste("p-value sur l'ensemble", pval_format(overall_p$p.value))
pval_format(x_p_values)

```

Donc on peut dire que le pourcentage de bonnes reponses est plus élevé après, pour l'ensemble ainsi que pour les sous-groupes.