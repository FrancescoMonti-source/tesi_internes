---
# General Information --------------------------------------------------------
title:    "Thèse - Rachel Frébourg"
subtitle: "Comparaison avant-après niveau interdisciplinarité chez les pro de santé"
author:   "Francesco MONTI"
date:     "`r Sys.time()`" # Automatic date and time
# Document Format and Appearance ---------------------------------------------
# type ?html_document for more details
output:
    bookdown::html_document2: 
        toc:         yes        # Table of contents (toc): yes no
        toc_float:   yes        # yes no
        toc_depth:   5              # 1 2 3 4 5
        highlight : pygments      # default tango kate monochrome espresso pygments...
        highlight_downlit : FALSE      # TRUE to use the downlit package as syntax highlight engine to highlight 
                                       # inline code and R code chunks (including providing hyperlinks to function 
                                       # documentation). The package needs to be installed to use this feature.
        code_folding:    "hide"     # none show hide
        code_download:   yes        # yes no
        fig_caption: yes        # yes no
        fig_width : 7
        fig_height : 5
        fig_retina : 2
        theme:       default        # cerulean journal flatly readable paper sandstone ...
        df_print:    default        # paged kable tibble default
        number_sections: yes        # Automatic numbering of sections: yes no
        anchor_sections : FALSE
        section_divs : TRUE     # Wrap sections in <div> tags, and attach identifiers to the enclosing <div> 
                                # rather than the header itself.
        dev : "png"                # Graphics device to use for figure output (defaults to png)
        self_contained : TRUE
        extra_dependencies : NULL    # Extra dependencies as a list of the html_dependency class objects typically 
                                     # generated by htmltools:htmlDependency().
        css : style.css     # CSS and/or Sass files to include. Files with an extension of .sass or .scss are compiled to 
                       # CSS via sass::sass(). Also, if theme is a bslib::bs_theme() object, Sass code may reference 
                       # the relevant Bootstrap Sass variables, functions, mixins, etc.
        includes : NULL        # Named list of additional content to include within the document 
                                # (typically created using the includes function)
        keep_md : FALSE        # Keep the markdown file generated by knitting.
        lib_dir : NULL             #    Directory to copy dependent HTML libraries (e.g. jquery, bootstrap, etc.) 
                                   # into. By default this will be the name of the document with _files appended to it.
        md_extensions : NULL       # Markdown extensions to be added or removed from the default definition of 
                                    # R Markdown. See the rmarkdown_format for additional details.
        pandoc_args : NULL      # Additional command line options to pass to pandoc
        template : "default"       # Pandoc template to use for rendering. Pass "default" to use the rmarkdown 
                                    # package default template; pass NULL to use pandoc's built-in template; 
                                    # pass a path to use a custom template that you've created. 
                                    # Note that if you don't use the "default" template then some features of 
                                    # html_document won't be available (see the Templates section below for more details).
        math_method : "default"     # Math rendering engine to use. This will define the math method to use with Pandoc.
                                    # It can be a string for the engine, one of "mathjax", "mathml", "webtex", "katex",
                                    # "gladtex", or "r-katex" or "default" for mathjax.
                                # It can be a list of
                                # - engine: one of "mathjax", "mathml", "webtex", "katex", or "gladtex". 
                                # - url: A specific url to use with mathjax, katex or webtex. 
                            # Note that for engine = "mathjax", url = "local" will use a local version of 
                            # MathJax (which is copied into the output directory).
                            # For example,
                            # output:
                            #    html_document:
                            #        math_method:
                            #        engine: katex
                            #        url: https://cdn.jsdelivr.net/npm/katex@0.11.1/dist
                            #        See Pandoc's Manual about Math in HTML for the details about Pandoc 
                            #        supported methods.

                        # Using math_method = "r-katex" will opt-in server side rendering using KaTeX thanks to 
                        # katex R package. 
                        # This is useful compared to math_method = "katex" to have no JS dependency, 
                        # only a CSS dependency for styling equation.
        mathjax : "default"        # Include mathjax. The "default" option uses an https URL from a MathJax CDN. 
                                    # The "local" option uses a local version of MathJax (which is copied into 
                                    # the output directory). You can pass an alternate URL or pass NULL 
                                    # to exclude MathJax entirely.
---


```{r chunk options, echo=F}
# Chunk options
knitr::opts_chunk$set(
  echo       = T,    # Should blocks with program code be shown in knitted documents?
  eval       = TRUE,    # Should program code be evaluated?
  fig.height = 6,       # Default height for plots.
  fig.width  = 10,       # Default width for plots.
  fig.align  = "center", # Default alignment for plots in knitted documents.
  warning = F
)

```

```{r libraries and data loading, include = F}

# LIBRARIES ----------------------------------------------------------------------------------
library(conflicted)    # Get a warning/error if several functions with the same name exist.
library(magrittr)      # Operator %>% and additional pipe-friendly functions.
library(tidyverse)     # The main "tidyverse" packages.
library(openxlsx)      # Write data to Excel files.
library(stringr)
library(knitr)
library(kableExtra)
library(pander)
library(DT)
library(janitor)

conflicted::conflicts_prefer(dplyr::filter)

# DATA ------------------------------------------------------------------------------------------
post = read.xlsx("Copie de resultats Q2 copie.xlsx", sheet = 1)
pre = read.xlsx("Copie de resultats Q1 copie.xlsx", sheet = 1)
```

```{r data management, include = F}
# Colnames() to lowercase
colnames(pre) = tolower(colnames(pre))
colnames(post) = tolower(colnames(post))

# MERGING PRE E POST ----------------------------------------------------------
pre = pre %>% 
    select(-contains(c("id","submitdate","lastpage","startlanguage"))) %>% 
    rename("filiere"=b1, "id" = a1) %>% 
    mutate(test = "pre")

post = post %>%
    filter(!is.na(submitdate)) %>% 
    select(-contains(c("id","submitdate","lastpage","startlanguage","x26","x27"))) %>% 
    rename("id" = a1) %>% 
    left_join(pre[,c("id","filiere")], by = "id") %>% 
    relocate(filiere, .after = "id") %>% 
    mutate(test = "post")

# Merging
data = rbind(pre,post) %>% tibble

# DATA MANAGEMENT merged DF ----------------------------------------------------
data = data %>% 
    mutate(across(s1q1:s7q2, as.numeric)) %>% 
    distinct() %>% 
    relocate(test, .after = "id") %>%
    mutate(filiere = case_when(filiere == "étudiant(e) en maïeutique" ~ "maieutique",
                               filiere == "étudiant(e) en orthophonie" ~ "orthophonie",
                               filiere == "étudiant(e) en pharmacie" ~ "pharmacie",
                               filiere == "étudiant(e) IDE" ~ "IDE",
                               filiere == "étudiant(e) MKE" ~ "MKE",
                               filiere == "interne de médecine générale" ~ "medecine generale",
                               TRUE ~ NA_character_
                               )
           )

# Adding mean score column
data = data %>% mutate(score = rowMeans(across(s1q1:s7q2),na.rm=T))
```


# Exploratory analysis
## Selection des questionnaires
```{r filtering out invidalid questionnaires, include = F}
rows_1 = nrow(data)
unique_ids_1 = n_distinct(data$id)

# Removing missing IDs rows (n=4)
data = data %>% filter(!is.na(id))
unique_ids_2 = n_distinct(data$id)
rows_2 = nrow(data)

# Computing missing values per row
data = data %>% filter(!is.na(id)) %>% 
    mutate(na_counts = rowSums(across(s1q1:s7q2, is.na)))

# Empty questionnaires
empty_q = sum(data$na_counts==20)


# Removing totally incomplete questionnaires
data = data %>% filter(na_counts<20)
unique_ids_3 = n_distinct(data$id)
rows_3 = nrow(data)

```

Au tout début on a **`r rows_1`** lignes et **`r unique_ids_1`** IDs.  
  <br>
Après avoir exclu 4 lignes à cause de missing ID, on descend à **`r (rows_1 - 4)`** questionnaires et **`r unique_ids_2`** IDs (l'ID "valeur manquante" n'est plus comptabilisé, c'est pour ça qu'on "perd" un ID).  
  <br>
Sachant que **`r unique_ids_2`**x2=**`r (unique_ids_2*2)`**on a **`r rows_2 - 760`** entrées de trop.
  <br>
On retrouve **`r empty_q`** questionnaires completement vides, qu'on peut exclure ce qui nous donne **`r rows_3`** questionnaires et **`r unique_ids_3`** IDs uniques.  
  <br>
On est tjrs très loin de notre objectif de environ **`r (unique_ids_2*2)`** questionnaires (**`r (unique_ids_3*2)`** maintenant qu'on a **`r unique_ids_3`** IDs).
  <br>

Donc, on a forcement des IDs pour lesquels on a **>2** entrées. Voyons de les mettre en evidence.

```{r IDs with too many entries}
data %>% 
    group_by(id) %>% 
    summarise(n=n()) %>%
    arrange(desc(n)) %>%
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))

problematic_IDs = data %>% group_by(id) %>% summarise(n=n()) %>% filter(n>2) %>% nrow

```
  
  <br>
Comme tu peux le voir on semble avoir `r problematic_IDs` IDs presents **au moins** 3 fois.
  <br>
Creusons plus loin pour voir si on identifie un groupe d'IDs problematique. Théoriquement, si les gens avaient respecté les régles pour la création de l'identifiant anonyme, l'identifiant devrait suivre le *pattern* suivant: 1 chiffre - 2 lettres - 2 chiffres.  

Voyons pour combien de lignes ce *pattern* est respecté:
```{r looking for IDs not following the rules}
str_detect(data$id, "[:digit:]{1}[:alpha:]{2}[:digit:]{2}") %>% 
    table %>%
    pander
```

Cela nous dit que **même si** on regarde seulement les gens qui ont respecté la procedure pour la création des IDs, on à tjrs des lignes de trop. D'abord, regardons les entrés des gens qui ont tapé un ID au pif.

```{r dataframe IDs aberrants}
data %>% 
    filter(!str_detect(id, "[:digit:]{1}[:alpha:]{2}[:digit:]{2}")) %>%
    arrange(id) %>% 
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))
```
  
  <br>
Néanmoins, s'ils ont utilisé 2 fois **le même** identifiant *aberrant* on pourra quand même les apparier. Voyons donc les IDs qui apparaissent **>2** fois. Les IDs  *aberrants* qui apparaissent **2** fois on peut les utiliser, les IDs qui apparaissent qu'une seule fois, idem, on peut les garder pour la partie descriptive (carrement ils ne sera pas possible de les utiliser pour la comparaison avant-après).
  <br>
  
```{r IDs aberrants presentes 2+ fois}
data %>% 
    filter(!str_detect(id, "[:digit:]{1}[:alpha:]{2}[:digit:]{2}")) %>%
    group_by(id) %>%
    summarise(n=n()) %>% 
    arrange(desc(n)) %>%
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))
```
  
On voit que le seul ID problematique parmi les *aberrants* est **"12345"**.<br>
Est-ce que la filière pourrait nous aider? Voyons.

```{r filtering on ID "12345"}
data %>% 
    filter(id=="12345") %>%
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))
```
  
On semble avoir 1 IDE et 1 MG, qui ont un doublon de "2ème test". 
Si on regarde avec attention la ligne 3 et 4 sont identiques, avec une "filière" différente. <br>
Si la ligne 3 et 4 étaient par exemple "IDE" et la ligne 5 et 6 étaient "medecine generale" on aurait identifié des doublons --> problème résolu. 
Mais dans ce cas on a des doublons **ET** 2 personnes qui ont rentré 2 fois le "2ème test" en changeant aussi de filière. Ou Il est donc impossible de rattacher ces questionnaires à un "test 1".
Ce qui est très très bizarre, est que les lignes 3 et 5 sont IDENTIQUES aux lignes 4 et 6. Ce qu'on peut faire, est prendre la moyenne des lignes 3-5 et 4-6. Le même approche nous sera utile pour gérer les IDs *non aberrants* doublons qui sont les suivants:


```{r IDs non aberrants de trop}
data %>% 
    filter(str_detect(id, "[:digit:]{1}[:alpha:]{2}[:digit:]{2}")) %>%
    group_by(id) %>%
    mutate(n=n()) %>% 
   filter(n>2) %>%
    relocate(n, .after = id) %>% 
    arrange(desc(n)) %>% 
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))


data = data%>%
     group_by(id, test, filiere) %>%
     summarise(across(s1q1:last_col(), ~mean(., na.rm = TRUE)), .groups = "drop")
```
  

Vu que "ID" ne suffit pour identifier uniquement les lignes, si on prend "ID" + "test" + "filiere" et on fait la moyenne des lignes ambigues on devrait s'en sortir pas mal.
Cela nous laisse avec `r nrow(data)` questionnaires. <br>
Bon, on sait dejà qu'on a des IDs qui apparaissent trop souvent mais si on prend ID-filiere, est-ce que maintenant on a max 2 lignes par couple ID-filiere?
  

```{r}
data %>% 
    group_by(id,filiere) %>%
    summarise(n=n()) %>% 
    arrange(desc(n)) %>%
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             ))

```
  
Oui! Nous avons maintenant 413 identité uniques données par ID+FILIERE. Vu qu'on a besoin de "filière" pour identifier les gens, on va esclure les lignes où "filière" n'est pas renseigné.


```{r}
filiere_na = data %>% filter(is.na(filiere)) %>% nrow()

# REMOVING MISSING "filiere" rows
data = data %>% filter(!is.na(filiere))

# How many questionnaires left?
questionnaires = nrow(data)
# How many unique identifties?
ids = data %>% distinct(id,filiere) %>% nrow


data %>% 
    group_by(id,filiere) %>%
    summarise(n=n()) %>% 
    arrange(desc(n))  %$% table(n) %>% pander(caption = "Nb questionnaires appariés et non")
```

On exclu donc `r filiere_na` lignes car valeur manquante. On est maintenant à **`r questionnaires`** questionnaires pour **`r ids`** identités. Voyons combien de gens on peut apparier. <br>
  
```{r}
data %>% 
    group_by(id,filiere) %>%
    summarise(n=n()) %>% 
    arrange(desc(n))  %$% table(n) %>% pander(caption = "Nb questionnaires appariés et non")
```
 
  



## Nb et repartition sujets participants
```{r }

data %>% distinct(id,filiere) %$% 
    table(filiere) %>% 
    as.data.frame() %>% 
    mutate("%" = round(Freq/sum(Freq)*100, 2)) %>% 
    adorn_totals() %>% 
    pander(caption = "**Repartition sujets par filière**")
```

<br>

<br>

## Missing values

Voyons sur tout l'ensemble de tests, combien de données manquantes on a. Ce sont des "vraies" données manquantes **OU** des "NSP" qui n'était pas pertinents pour la question et vraisemblablement pris pour des "Ne sait pas".

```{r missing values}


table(data$na_counts) %>% 
    as.data.frame() %>% 
    mutate("%" = round(Freq/sum(Freq)*100, 2)) %>% 
    rename("Nb missing values" = Var1) %>% 
    pander(caption = "**Nb de valeurs manquantes par questionnaire**")

```

On voit que les tests sont bien complets globalement sauf 16 questionnaires qui sont **complétement** vides. Ils sont des doublons dus à des enregistrements vides.

<br>

<br>

### Missing values par filière

On peut voir que la repartition des valeurs manquantes par filière est en ligne avec la repartition des sujets par filière. Donc il n'y a pas une filière qui a laissé le questionnaire "plus vide" que les autres.

```{r}
data %>%
  group_by(filiere) %>%
  summarise(Freq = sum(na_counts)) %>%
  mutate("%" = round(Freq / sum(Freq) * 100, 2)) %>%
    adorn_totals() %>% 
  pander(caption = "**Valeurs manquantes par filière**", align = "center")


```

**!!!!!!** Quelque chose ne va pas, on a 379 sujets et 800+ questionnaires (on devrait en avoir **au max** 379\*2). Dans le tableau suivant on voit qu'on a 199 sujets avec **au moins** 3 entrées (et j'ai déjà exclu les 16 dont je parlais avant).

```{r message = F}
x <- data %>%
  group_by(id, filiere) %>%
  summarise(n = n()) %>%
  arrange(desc(n)) %>%
  filter(n > 2) %>%
  pull(id) 

data %>%
    filter(id %in% x) %>%
    arrange(id, filiere, test) %>%
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             )
              ) 
```

Les entrées supplementaires ne sont pas des "doublons", les valeurs ne sont pas les mêmes. Je vais donc prendre la moyenne de ces valeurs. Ci dessous le résultat, on est à 766 lignes alor que notre max theorique est 758. Il y a forcement des gens qui se sont enregistrés avec plus qu'un ID (j'ai renommé la variable "A1").   
Ca ne m'inquiète pas pour les tests appariés, je ne pense pas que des gens ont 2*2 tests appariés mais je controllerai.

```{r}
data %>% 
    group_by(id,test,filiere) %>% 
    summarise(across(s1q1:s7q2,mean,na.rm=T)) %>% 
    mutate(na_counts = rowSums(across(s1q1:s7q2, is.na))) %>% 
    datatable(options = list(pageLength = 10,
                             #dom = 't',
                             scrollX = TRUE,
                             width = "auto",
                             scrollX = T
                             )
              )
```

<br>

<br>

# Tests appariés

```{r Cas appariés par filière}
# DF with id-filiere-pre-post pour les tests stat
test_data <- data %>%
  group_by(id, filiere, test) %>%
  summarise(mean_score = mean(c_across(s1q1:s7q2), na.rm = T)) %>%
  pivot_wider(names_from = "test", values_from = "mean_score") %>%
    filter(!is.na(post),!is.na(pre)) %>% distinct

# paired cases by filiere
test_data %$% 
    table(filiere) %>% 
    as.data.frame() %>% 
    mutate("%" = round(Freq/sum(Freq)*100, 2)) %>% 
    adorn_totals() %>% 
    pander(caption = "Cas appariés par filière")
```

Pour ces pourcentages les denominateur est "total de tests appariés" et non le "nombre total de tests. Donc, les IDE, representent 38.14% des tests appariés disponibles.

Mais, il y a carrement plus d'IDE que les autres filières! Oui, bien sur. Voyons

# Tests stat

```{r analysis}
# PRE vs POST, toutes filieres confondues
t.test(test_data$post,test_data$pre, paired=T)

# PRE vs POST, filiere par filiere 
t.test(test_data$post[test_data$filiere=="IDE"],test_data$pre[test_data$filiere=="IDE"], paired=T)

```
